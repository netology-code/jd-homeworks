## Задача 1. Робот-доставщик

## Описание

Представьте, что перед вашей командой поставили задачу на разработку программного обеспечения для робота-доставщика. Инструкции для робота содержат команды:
- R - поверни направо;
- L - поверни налево;
- F - двигайся вперед.

В процессе построения карты маршрутов, вам поручили проанализировать разнообразие существующих путей.
Для генерации маршрутов вы используете функцию:
```java
    public static String generateRoute(String letters, int length) {
        Random random = new Random();
        StringBuilder route = new StringBuilder();
        for (int i = 0; i < length; i++) {
            route.append(letters.charAt(random.nextInt(letters.length())));
        }
        return route.toString();
    }
```
Напишите многопоточную программу, которая в каждом потоке генерирует текст: `generateRoute("RLRFR", 100)`, считает количество команд поворота направо (буквы `'R'`) и выводит на экран результат. Количество потоков равно количеству генерируемых маршрутов и равно `1000`.

Так как буква `'R'` в параметре генератора упомянута три раза из пяти, то в среднем, количество букв `'R'` должно составлять 60% от всех команд инструкции, т.е. где-то около 60 от общего числа маршрутов. Однако, т.к. процесс вероятностный, точное количество раз которое встретится эта буква в каждом маршруте может немного отклоняться от среднего значения.

Запустив программу, вы обратили внимание, что размеры промежутков с буквой `'R'` часто повторяются и вам стало интересно, какие размеры попадаются чаще всего.

Для этого вы завели мапу (`HashMap`) в статическом поле `public static final Map<Integer, Integer> sizeToFreq`, которая после завершения потоков должна хранить в ключах попавшиеся частоты буквы `'R'`, а в значениях - количество раз сколько они попались.
В итоге, обработав каждую строку, вам нужно будет обновить эту мапу, увеличив значение для полученной частоты в ней на 1 (а если частоты в мапе не было - просто вставить значение 1).

Однако возникает проблема - `HashMap` не потокобезопасна, к ней нельзя обращаться из разных потоков "одновременно".
Решением этой проблемы будет использование блока синхронизации (`synchronized`).

Реализуйте этот функционал и в конце основного потока выведите сообщение вида:
```text
Самое частое количество повторений 61 (встретилось 9 раз)
Другие размеры:
- 60 (5 раз)
- 64 (3 раз)
- 62 (6 раз)
...
```
## Реализация

1. Заведите `HashMap` в статическом поле `public static final Map<Integer, Integer> sizeToFreq`;
2. При обработке каждой строки увеличьте счётчик в `HashMap`;
3. Используйте `synchronized` для потокобезопасного доступа к `HashMap`.

На проверку отправьте ссылку на репозиторий с решением.
